\section{Typed Open Automata}
\begin{frame}{Typed Open Automata}
  A typed open automaton is a tuple $A=\langle S, s_0, E, V, \phi_0, T\rangle$, where
  \begin{itemize}
    \item $S$ is the set of states
    \item $s_0\in S$ is the initial state
    \item $E\subset S$ is the set of terminal states
    \item $V$ is the set of variables
    \item $\psi_0: V\to\P$ is the initial assignment
    \item $T$ is the set of transitions. Each $t\in T$ has the form $\dfrac{\beta_{j}^{j\in J}, g, \psi}{s\xrightarrow{\alpha}s'}$, where
          \begin{itemize}
            \item [$\circ$]$s,s'\in S$ and $\alpha$ is an emitted action.
            \item [$\circ$] each $\beta_{j}$ has the form $p\to q(m : D)$ or $p\to q(\ell)$ such that $p,q\in \ZZ\cup\infty$, $p\ne q$, $pq\ge0$ and $\ell\in\L$.
            \item [$\circ$] $g$ is a predicate over $V$
            \item [$\circ$] $\psi: V\to \E_V$ is a reassignment
          \end{itemize}
  \end{itemize}
  We can ignore the emitted action and write $s\xrightarrow{\beta_{j}^{j\in J}, g, \psi}s'$. A pair $(s, \phi)$, where $s\in S$ and $\phi:V\to\P$ is called a configuration of the automaton.
\end{frame}

\begin{frame}{Example}
  Consider a producer-consumer communication through a size-2 circular buffer. This is modeled as an automaton $A$.

  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

      \node[]               (init_assign){};
      \node[state, accepting] (s_0) [right=4cm of init_assign] {$s_0$};

      \path[->]
      (init_assign) edge node {$\substack{
              M     \leftarrow [0,0,0] \\
              f, l  \leftarrow 0
            }$} (s_0)
      (s_0) edge[loop, in=135, out=45, looseness=4] node[anchor=south] {$\{-1\to0(m:\texttt{int})\}((l+1)\%2\ne f)\left\{\substack{M[l]\leftarrow m\\l\leftarrow (l+1)\%2}\right\}$} (s_0)
      (s_0) edge[loop, in=-45, out=-135, looseness=4] node[anchor=north] {$\{0\to -2(M[f]:\texttt{int})\}(f\ne l)\{f\leftarrow (f+1)\%2\}$} (s_0)
      ;
    \end{tikzpicture}
  \end{figure}
\end{frame}

\begin{frame}{Type Generated by an OA}
  Consider $A=\langle S, s_0, E, V, \phi_0, T\rangle$.
  \begin{itemize}
    \item $\llbracket p\to q(m : D)\rrbracket = p\to q(D)$
    \item $\llbracket p\to q(\ell)\rrbracket = p\to q(\ell)$
    \item $\llbracket \beta_1,\ldots,\beta_n \rrbracket = \llbracket \beta_1 \rrbracket | \ldots | \llbracket \beta_n \rrbracket$
  \end{itemize}
\end{frame}

\begin{frame}{Weak type}
  The weak type $W_A$ generated by $A$ is derive from the graph, called the weak type graph, such that
  \begin{itemize}
    \item The set of nodes is $S$, the initial node is $s_0$, the set of terminal nodes is $E$
    \item Each transition $s\xrightarrow{\beta_{j}^{j\in J}, g, \psi}s'$ has a corresponding edge $s\xrightarrow{\llbracket \beta_{j}^{j\in J} \rrbracket}s'$
  \end{itemize}

  \textbf{Example:} The weak type graph for producer-consumer. Let $U=-1\to0(\texttt{int})$ and $V=0\to -2(\texttt{int})$. The type is $W_A=\mu\alpha.(\texttt{end}+U+V).\alpha$

  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

      \node[state, accepting] (s_0) [below=2cm of init_assign] {$s_0$};

      \path[->]
      (s_0) edge[loop, in=135, out=45, looseness=4] node[anchor=south] {$-1\to0(\texttt{int})$} (s_0)
      (s_0) edge[loop, in=-45, out=-135, looseness=4] node[anchor=north] {$0\to -2(\texttt{int})$} (s_0)
      ;
    \end{tikzpicture}
    \caption{The DFA generated by the weak type of $A$}
  \end{figure}
\end{frame}

\begin{frame}{Strong type}
  The strong type graph $G_S$ has nodes as \textit{configurations}. The initial node is $(s_0,\phi_0)$. Terminal nodes are $(s, \psi)$ where $s\in E$.

  Each $(s,\phi)\xrightarrow{\beta_{j}^{j\in J}, g, \psi}(s',\phi')$ corresponds to an edge $(s,\phi)\xrightarrow{\llbracket\beta_{j}^{j\in J}\rrbracket}(s',\phi')$.

  The graph $G_S$ derives the strong type $S_A$.

  We should be able to show that $S_A\preceq W_A$.

  \textbf{Example:} The strong type graph for producer-consumer.

\end{frame}

\begin{frame}{Strong type}
  \begin{figure}
    \centering
    \resizebox{0.5\textwidth}{!}{
      \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

        \node[state, accepting] (w_00) {$\substack{s_0\\ f=l=0}$};
        \node[state, accepting] (w_01) [right=2cm of w_00] {$\substack{s_0\\ f=0,l=1}$};
        \node[state, accepting] (w_02) [right=2cm of w_01] {$\substack{s_0\\ f=0,l=2}$};

        \node[state, accepting] (w_11) [below=2cm of w_01] {$\substack{s_0\\ f=1,l=1}$};
        \node[state, accepting] (w_12) [below=2cm of w_02] {$\substack{s_0\\ f=1,l=2}$};

        \node[state, accepting] (w_10) [right=2cm of w_12] {$\substack{s_0\\ f=1,l=0}$};

        \node[state, accepting] (w_20) [below=2cm of w_10] {$\substack{s_0\\ f=2,l=0}$};
        \node[state, accepting] (w_22) [below=2cm of w_12] {$\substack{s_0\\ f=2,l=2}$};

        \node[state, accepting] (w_21) [right=2cm of w_20] {$\substack{s_0\\ f=2,l=1}$};


        \path[->]
        (w_00) edge[] node[anchor=south] {$U$} (w_01)
        (w_01) edge[] node[anchor=south] {$U$} (w_02)

        (w_01) edge[] node {$V$} (w_11)
        (w_02) edge[] node {$V$} (w_12)

        (w_11) edge[] node {$U$} (w_12)

        (w_12) edge node {$U$} (w_10)
        (w_12) edge node {$V$} (w_22)
        (w_22) edge node {$U$} (w_20)

        (w_10) edge node {$V$} (w_20)
        (w_20) edge node {$U$} (w_21)

        (w_20) edge[out=-90, in=-90] node {$V$} (w_00)
        (w_21) edge[out=90, in=90] node[anchor=south] {$V$} (w_01)
        ;
      \end{tikzpicture}}
  \end{figure}
\end{frame}

\begin{frame}{Strong type}

  However, the strong type does not always exist i.e. strong type graph generation does not always halt.

  \textbf{Example:}  Consider a key-generating protocol, where the server request generating a secret key for the client to use later. The number of key consumptions cannot exceed the number of key generation requests. This is modeled as an automaton $B$.

  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

      \node[]               (init_assign){};
      \node[state, accepting] (s_0) [right=4cm of init_assign] {$s_0$};

      \path[->]
      (init_assign) edge node {$\substack{
              n\leftarrow 0\\
              m\leftarrow new \, key()
            }$} (s_0)
      (s_0) edge[loop, in=135, out=45, looseness=4] node[anchor=south] {$\{-1\to0()\}(\text{True})\left\{n\leftarrow n+1\right\}$} (s_0)
      (s_0) edge[loop, in=-45, out=-135, looseness=4] node[anchor=north] {$\{0\to -2(m:\texttt{string})\}(n>0)\left\{\substack{n\leftarrow n-1\\  m\leftarrow new \, key()}\right\}$} (s_0)
      ;
    \end{tikzpicture}
  \end{figure}
\end{frame}

\begin{frame}{Relaxed type}
  A relaxed type graph $G_R$ has nodes of the form $(s,P)$, where $P$ is a predicate over $V$. \textit{The} initial node is $(s_0,P_0)$ such that $\phi_0\vdash P_0$. Terminal nodes are $(s, P)$ where $s\in E$.

  Each $(s,\phi)\xrightarrow{\beta_{j}^{j\in J}, g, \psi}(s',\phi')$ corresponds to an \textit{edges} $(s,P)\xrightarrow{\llbracket\beta_{j}^{j\in J}\rrbracket}(s',P')$ such that $\phi\vdash P$ and $\phi'\vdash P'$

  The graph $G_R$ derives the strong type $R_A$.

  We should be able to show that $S_A\preceq R_A\preceq W_A$.
\end{frame}

\begin{frame}{Relaxed type}
  \textbf{Example:} Let $X=-1\to0(\texttt{void})$ and $Y=0\to -2(\texttt{string})$. We have relaxed type graph for key-generating protocol which derives
  $$R_B=\mu\alpha_0.X.\mu\alpha_1.(X.\alpha_1+ Y.\alpha_1 + Y.\alpha_0).$$
  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

      \node[state, accepting] (s_0) [below=2cm of init_assign] {$s_0, n=0$};

      \node[state, accepting] (s_1) [right=3cm of s_0] {$s_0, n>0$};

      \path[->]
      (s_0) edge[out=45, in=135] node[anchor=south] {$X$} (s_1)
      (s_1) edge[loop, out=45, in=-45, looseness=4] node[] {$X,Y$} (s_1)
      (s_1) edge[out=-135, in=-45] node[] {$Y$} (s_0)
      ;
    \end{tikzpicture}
  \end{figure}
\end{frame}

\begin{frame}{Relaxed type}
  \textbf{Example:} Another relaxed type graph for key-generating protocol. It derives $R'_B$.
  \begin{figure}[ht]
    \centering
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

      \node[state, accepting] (s_0) [below=2cm of init_assign] {$s_0, n=0$};
      \node[state, accepting] (s_1) [right=3cm of s_0] {$s_0, n=1$};
      \node[state, accepting] (s_2) [right=3cm of s_1] {$s_0, n>1$};

      \path[->]
      (s_0) edge[out=45, in=135] node[anchor=south] {$X$} (s_1)
      (s_1) edge[out=-135, in=-45] node[] {$Y$} (s_0)

      (s_1) edge[out=45, in=135] node[anchor=south] {$X$} (s_2)
      (s_2) edge[out=-135, in=-45] node[] {$Y$} (s_1)

      (s_2) edge[loop, out=45, in=-45, looseness=4] node[] {$X,Y$} (s_2)
      ;
    \end{tikzpicture}
  \end{figure}
  Note that $R'_B\prec R_B$ (strictly) but $R'_B\downharpoonright_{-1}\equiv R_B \downharpoonright_{-1}$.
\end{frame}


\begin{frame}{Directions}
  Let $\S(A)$ be the set of types generated by $A$ (strongly, weakly and relaxedly). We attempt to prove or disprove that
  \begin{itemize}
    \item $\S(A)$ is totally ordered. In particular, if $S_1$ and $S_2$ are generated by an automaton $A$, then $S_1\preceq S_2$ if and only if the number of nodes $\text{gr}(S_1)$ is greater than or equal to the number of nodes in $\text{gr}(S_2)$.
    \item If there exist $S_1,S_2\in\S(A)$ such that $S_1\not\equiv S_2$ and $S_1\downharpoonright_p \equiv S_2\downharpoonright_p$. Then $S\downharpoonright_p\equiv S_1\downharpoonright_p$, for every $S\in \S(A)$.
  \end{itemize}
  \textbf{Note:} If the latter is correct, we may be sure about the type of a child without knowing the strong type of the parent.
\end{frame}

\begin{frame}{Composition}
  Consider an automaton
  $$A=\llangle S_A, s_{0A}, E_A, V_A, \psi_{0A}, T_A\rrangle \text{ and } B=\llangle S_B, s_{0B}, E_B, V_B, \psi_{0B}, T_B\rrangle.$$

  An automaton $B$ can be safely composed to the child indexed by $p$ of the automaton $A$ if $\inf \S(B) \preceq \inf \{S\downharpoonright_p | S\in \S(A)\}$.

  Reindex children of $A$ and $B$ if there is any conflict.
\end{frame}

\begin{frame}{Composition}
  The composition of $B$ into the internal component indexed by $p<0$ of $A$ yields an open automaton $A[B/p]:=C=\llangle S_C, s_{0C}, E_C, V_C, \psi_{0C}\rrangle$, such that
  \begin{itemize}
    \item $S_C = S_A\times S_B$
    \item $s_{0C} = (s_{0A}, s_{0B})$
    \item $E_C = E_A\times E_B$
    \item $V_C = V_A\uplus V_B$
    \item $\psi_C = \psi_A\uplus \psi_B$
    \item $T_C = \ldots$
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{align*}
    T_C & = \left\{\dfrac{\beta_{j''}^{j''\in J''}, g\wedge g', \psi\uplus\psi'}{(s,s')\xrightarrow{\alpha} (t,t')}\Bigg|\dfrac{\beta_{j}^{j\in J}, g, \psi}{s\xrightarrow{\alpha} t}\in T_A\wedge \dfrac{\beta_{j'}^{j'\in J'}, g', \psi'}{s'\xrightarrow{\alpha'} t'}\in T_B\wedge \llbracket \beta_{j'}^{j'\in J'}\rrbracket \preceq \llbracket \beta_{j}^{j\in J}\rrbracket\downharpoonright_p \right\}                   \\
        & \bigcup \left\{\dfrac{\beta_{j}^{j\in J}, g, \psi}{(s,s')\xrightarrow{\alpha} (t,t')}\Bigg|s',t'\in S_B\wedge\dfrac{\beta_{j}^{j\in J}, g, \psi}{s\xrightarrow{\alpha} t}\in T_A \wedge \left(\not\exists\dfrac{\beta_{j'}^{j'\in J'}, g', \psi'}{s'\xrightarrow{\alpha'} t'}\in T_B, \llbracket \beta_{j'}^{j'\in J'}\rrbracket \preceq \llbracket \beta_{j}^{j\in J}\rrbracket\downharpoonright_p\right) \right\} \\
        & \bigcup \left\{\ldots\Bigg|\dfrac{\beta_{j'}^{j'\in J'}, g', \psi'}{s'\xrightarrow{\alpha'} t'}\in T_B\wedge \left(\not\exists \dfrac{\beta_{j}^{j\in J}, g, \psi}{s\xrightarrow{\alpha} t}\in T_A, \llbracket \beta_{j'}^{j'\in J'}\rrbracket \preceq \llbracket \beta_{j}^{j\in J}\rrbracket\downharpoonright_p\right) \right\}
  \end{align*}

  We have to work more on the last set. Generally speaking, all other communications in $B$ become internal communication in $A[B/p]$.
\end{frame}

\begin{frame}{Plans}
  \begin{itemize}
    \item That $\inf \S(A[B/p]) \prec \inf \S(A)$ is not straightforward
  \end{itemize}
\end{frame}