\section{Idea}
\begin{frame}{Compatible type}
  We want to make use of projection for OA-type compatibility.

  Unify a set of session types $S$ such that $\downharpoonright_p : S\to S$.

  Introduce sets of internal components (holes) $\mathcal{C}_I$ and external components $\mathcal{C}_E$; self component $\sigma$ and parent component $\rho$. The set of component identifiers is $\mathcal{C} = \mathcal{C}_I \uplus \mathcal{C}_E \uplus \{\sigma, \rho\}.$

  Idea for projection:
  \begin{align*}
    (x\rightarrow \sigma)\downharpoonright_x  & = (\sigma\rightarrow\rho)                              \\
    (\sigma \rightarrow x)\downharpoonright_x & = (\rho\rightarrow\sigma)                              \\
    (x\rightarrow y)\downharpoonright_x       & = (\sigma\rightarrow y)         & (y\in \mathcal{C}_I) \\
    (y\rightarrow x)\downharpoonright_x       & = (y\rightarrow \sigma)         & (y\in \mathcal{C}_I) \\
                                              & \text{empty string, otherwise}.
  \end{align*}
\end{frame}

\begin{frame}{Hole actions}
  Each hole action becomes $p\rightarrow q (v : D)$

  Asynchrony: a transition has more than one hole actions (there have been attempts for session type with new semantics).

  Internal computation: a transition with no hole actions.

  Privacy: The main OA can be seen as the main thread, environment, observer or mediator.
  \begin{itemize}
    \item The main OA cannot see internal computation of its internal components.
    \item If two internal components pass message to each other, it can see but not affect.
  \end{itemize}

  Nondeterministic can be modeled using union type $G+G$.
\end{frame}

\begin{frame}{Objectives}

  \begin{itemize}
    \item Carefully formalize compatible type syntax, projection and compatibility.
    \item Develop an algorithm to infer global type from a configuration.
    \item Refine the notion of compatibility.
          \begin{itemize}
            \item [$\circ$] After a transition, the new configuration is compatible with which type?
            \item [$\circ$] The type generated by an OA can be seen as \textit{strong compatibility}. We can define weak compatibility (using subtyping?).
          \end{itemize}
    \item Prove deadlock absence over composition.
    \item Further: is there any relation between bisimulation and compatibility?
  \end{itemize}
\end{frame}