\section{Extended Multiparty Session Type}
\subsection{Syntax}
We refine the grammar so that we do not have to use indices in the rule for asynchrony.

\begin{figure}[ht]
  $$\begin{array}{lclr}
      T & ::= & S & \text{(session type)} \\
        & |   & D & \text{(data type)}
    \end{array}$$

  \begin{center}
    \begin{minipage}{0.45\textwidth}
      $$\begin{array}{lclr}
          S & ::= & \texttt{end} & \text{(termination)}    \\
            & |   & L.S          & \text{(sequence)}       \\
            & |   & \mu\alpha.S  & \text{(recursion)}      \\
            & |   & \alpha       & \text{(type variable)}  \\
            & |   & (S+S)        & \text{(nondeterminism)} \\
        \end{array}$$
    \end{minipage}
    \hfill
    \begin{minipage}{0.53\textwidth}
      $$\begin{array}{lclr}
          L    & ::= & L | L                                                         & \text{(asynchrony)}   \\
               & |   & p\rightarrow q(D)                                             & \text{(send-receive)} \\
               & |   & \texttt{skip}                                                 & \text{(skip)}         \\
          p,q  & \in & \ZZ\cup\{\infty\}, p\ne q, pq\ge 0                            & \text{(index)}        \\
          D    & ::= & \ell | \texttt{bool} | \texttt{int} | \texttt{string} |\ldots &                       \\
          \ell & \in & \L                                                            & \text{(label)}        \\
        \end{array}$$
    \end{minipage}
  \end{center}
  \caption{The syntax of extended multiparty session type}
  \label{syntax}
\end{figure}

\subsection{Relations between types}
We can show that the syntax is right-linear. Hence, each type is equivalent to a regular expression and has a corresponding DFA. We concern about the following relations between types

\begin{itemize}
  \item Subtype: $S_1\preceq S_2$ if the DFA generated by $S_2$ trace-simulates the DFA generated by $S_1$.
  \item Type equivalence: $S_1\equiv S_2$ if $S_1\preceq S_2$ and $S_2\preceq S_1$.
\end{itemize}

We also denote by $\prec$ strict subtype i.e. if $S_1\prec S_2$, then $S_1\preceq S_2$ and $S_1\not\equiv S_2$. One problem for this not enough to model subtyping in our context is that we also want these things

\begin{itemize}
  \item More specialized components should be safely plugged into more general interfaces: $$\infer{p\rightarrow q(D_1) \preceq p\rightarrow q(D_2)}{D_1\preceq D_2}.$$
  \item Waiting for more actions to be asynchronously executed is permissible:
        $$L_1|L_2 \preceq L_1$$
\end{itemize}

We may extend the notion of simulation to include this kind of subtyping. But the best thing we can do is to define \textit{equational rules}. For regular expressions, we have Kleen algebra. I was wrong as I oversimplified the rules in the last draft. Maybe there has already been in literature such equational reasoning on right-linear logic.

\section{Typed Open Automata}
\begin{example}
  Consider an automaton $A$ for the producer-consumer protocol through a circular buffer of size $2$, depicted in Figure \ref{fig:prod-con}. Let $U = -1\to 0 (\texttt{int})$ and $V = 0\to -2 (\texttt{int})$. The DFA of its weak type $W_A$ is as in Figure \ref{fig:weak-type}.
  \begin{equation}
    W_A=\mu\alpha.(U+V).\alpha
  \end{equation}
  The DFA of its strong type $S_A$ is as in Figure \ref{fig:strong-type}.
\end{example}

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

    \node[]               (init_assign){};
    \node[state, accepting] (s_0) [right=4cm of init_assign] {$s_0$};

    \path[->]
    (init_assign) edge node {$\substack{
            M     \leftarrow [0,0,0] \\
            f, l  \leftarrow 0
          }$} (s_0)
    (s_0) edge[loop, in=135, out=45, looseness=4] node[anchor=south] {$\{-1\to0(m:\texttt{int})\}((l+1)\%2\ne f)\left\{\substack{M[l]\leftarrow m\\l\leftarrow (l+1)\%2}\right\}$} (s_0)
    (s_0) edge[loop, in=-45, out=-135, looseness=4] node[anchor=north] {$\{0\to -2(M[f]:\texttt{int})\}(f\ne l)\{f\leftarrow (f+1)\%2\}$} (s_0)
    ;
  \end{tikzpicture}
  \caption{An automaton for producer-consumer protocol though a size-3 circular buffer}
  \label{fig:prod-con}
\end{figure}


\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

    \node[state, accepting] (s_0) [below=2cm of init_assign] {$s_0$};

    \path[->]
    (s_0) edge[loop, in=135, out=45, looseness=4] node[anchor=south] {$-1\to0(\texttt{int})$} (s_0)
    (s_0) edge[loop, in=-45, out=-135, looseness=4] node[anchor=north] {$0\to -2(\texttt{int})$} (s_0)
    ;
  \end{tikzpicture}
  \caption{The DFA generated by the weak type of $A$}
  \label{fig:weak-type}
\end{figure}

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

    \node[state, accepting] (w_00) {$\substack{s_0\\ f=l=0}$};
    \node[state, accepting] (w_01) [right=2cm of w_00] {$\substack{s_0\\ f=0,l=1}$};
    \node[state, accepting] (w_02) [right=2cm of w_01] {$\substack{s_0\\ f=0,l=2}$};

    \node[state, accepting] (w_11) [below=2cm of w_01] {$\substack{s_0\\ f=1,l=1}$};
    \node[state, accepting] (w_12) [below=2cm of w_02] {$\substack{s_0\\ f=1,l=2}$};

    \node[state, accepting] (w_10) [right=2cm of w_12] {$\substack{s_0\\ f=1,l=0}$};

    \node[state, accepting] (w_20) [below=2cm of w_10] {$\substack{s_0\\ f=2,l=0}$};
    \node[state, accepting] (w_22) [below=2cm of w_12] {$\substack{s_0\\ f=2,l=2}$};

    \node[state, accepting] (w_21) [right=2cm of w_20] {$\substack{s_0\\ f=2,l=1}$};


    \path[->]
    (w_00) edge[] node[anchor=south] {$U$} (w_01)
    (w_01) edge[] node[anchor=south] {$U$} (w_02)

    (w_01) edge[] node {$V$} (w_11)
    (w_02) edge[] node {$V$} (w_12)

    (w_11) edge[] node {$U$} (w_12)

    (w_12) edge node {$U$} (w_10)
    (w_12) edge node {$V$} (w_22)
    (w_22) edge node {$U$} (w_20)

    (w_10) edge node {$V$} (w_20)
    (w_20) edge node {$U$} (w_21)

    (w_20) edge[out=-90, in=-90] node {$V$} (w_00)
    (w_21) edge[out=90, in=90] node[anchor=south] {$V$} (w_01)
    ;
  \end{tikzpicture}
  \caption{The DFA generated by the strong type of $A$}
  \label{fig:strong-type}
\end{figure}


\begin{example}
  Consider a key-generating protocol, where the server request generating a secret key for the client to use later. The number of key consumptions cannot exceed the number of key generation requests. This protocol is modeled as an automaton $B$ in Figure \ref{fig:key-generation}. Intuitively, any server able to request continuously and any client able to consume continuously should be able to composed to the components.
\end{example}


\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

    \node[]               (init_assign){};
    \node[state, accepting] (s_0) [right=4cm of init_assign] {$s_0$};

    \path[->]
    (init_assign) edge node {$\substack{
            n\leftarrow 0\\
            m\leftarrow new \, key()
          }$} (s_0)
    (s_0) edge[loop, in=135, out=45, looseness=4] node[anchor=south] {$\{-1\to0()\}(\text{True})\left\{n\leftarrow n+1\right\}$} (s_0)
    (s_0) edge[loop, in=-45, out=-135, looseness=4] node[anchor=north] {$\{0\to -2(m:\texttt{string})\}(n>0)\left\{\substack{n\leftarrow n-1\\  m\leftarrow new \, key()}\right\}$} (s_0)
    ;
  \end{tikzpicture}
  \caption{An automaton for the key generation protocol}
  \label{fig:key-generation}
\end{figure}

Let $X=-1\to0(\texttt{void})$ and $Y=0\to -2(\texttt{string})$. The weak type for $B$ is

\begin{equation}
  W_B = \mu\alpha.(X+Y).\alpha
\end{equation}

We cannot derive strong type for this automaton, because there are infinitely many values $n$ can take. However, we can use predicate on configurations (what I meant by abstracting away) to derive a type, as shown in Figure \ref{fig:key-gen-type}. The type is

\begin{equation}
  T_B = \mu\alpha_0.X.\mu\alpha_1.((X+Y).\alpha_1 + Y.\alpha_0)
\end{equation}

We should be able to show that $T_B\preceq W_B$.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

    \node[state, accepting] (s_0) [below=2cm of init_assign] {$s_0, n=0$};

    \node[state, accepting] (s_1) [right=3cm of s_0] {$s_0, n>0$};

    \path[->]
    (s_0) edge[out=45, in=135] node[anchor=south] {$X$} (s_1)
    (s_1) edge[loop, out=45, in=-45, looseness=4] node[] {$X,Y$} (s_1)
    (s_1) edge[out=-135, in=-45] node[] {$Y$} (s_0)
    ;
  \end{tikzpicture}
  \caption{The DFA generated by a type of $B$}
  \label{fig:key-gen-type}
\end{figure}

Now return to the automaton $A$. We can use predicates on configurations to reduce the number of states in the DFA to derive a type $M_A$ as shown in Figure \ref{fig:middle-type}.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]

    \node[state, accepting] (m_0) {$\substack{s_0\\ (l-f)\% 4 = 0}$};
    \node[state, accepting] (m_1)[right=3cm of m_0] {$\substack{s_0\\ (l-f)\% 4 = 1}$};
    \node[state, accepting] (m_2)[right=3cm of m_1] {$\substack{s_0\\ (l-f)\% 4 = 2}$};

    \node[state, accepting] (m_3)[right=3cm of m_2] {$\substack{s_0\\ (l-f)\% 4 = 3}$};


    \path[->]
    (m_0) edge[out=45, in=135] node {$U$} (m_1)
    (m_1) edge[out=-135, in=-45] node {$V$} (m_0)

    (m_1) edge[out=45, in=135] node {$U$} (m_2)
    (m_2) edge[out=-135, in=-45] node {$V$} (m_1)

    (m_2) edge[out=45, in=135] node {$U$} (m_3)
    (m_3) edge[out=-135, in=-45] node {$V$} (m_2)
    ;
  \end{tikzpicture}
  \caption{The DFA generated by the strong type of $A$}
  \label{fig:middle-type}
\end{figure}

We should be able to show that

\begin{equation}
  S_A\preceq M_A\preceq W_A
\end{equation}

Indeed, $M_A\equiv S_A$. Now I conjectured that

\begin{itemize}
  \item The set of types generated by an open automaton (whether by strong generation using all possible configurations, relaxed generation using predicates on configurations, or weak generation using only states) is totally ordered. In particular, if $T_1$ and $T_2$ are generated by an automaton $A$, then $T_1\preceq T_2$ if and only if the number of states in the DFA of $T_1$ is greater than or equal to the number of states in the DFA of $T_2$.
  \item If there exist $T_1$ and $T_2$ such that $T_1\not\equiv T_2$ and $T_1\downharpoonright_p \equiv T_2\downharpoonright_p \equiv\tau$. Then $T\downharpoonright_p\equiv\tau$, for every $T$ generated by $A$. If this is correct, instead of derive a possible non-existing strong type, we derive the weak type and a relaxed type. Of the projections of these types on a component are equivalent, we can be sure about the type of the component.
\end{itemize}


\section{Composition}

Up to now we have to refine the definition of an open automaton

\begin{definition} A typed open automaton is a tuple $A=\langle S, s_0, E, V, \phi_0, T\rangle$, where
  \begin{itemize}
    \item $S$ is the set of states
    \item $s_0\in S$ is the initial state
    \item $E\subset S$ is the set of terminal states
    \item $V$ is the set of variables
    \item $\psi_0: V\to\P$ is the initial assignment
    \item $T$ is the set of transitions. Each $t\in T$ has the form $\dfrac{\beta, g, \psi}{s\xrightarrow{\alpha}s'}$, where
          \begin{itemize}
            \item [$\circ$]$s,s'\in S$ and $\alpha$ is an emitted action.
            \item [$\circ$] $\beta$ has the form $p\to q(m : D)$, $p\to q(\ell)$, or an asynchronous composition of these, such that $\ell\in\L$, $p,q\in \ZZ\cup\infty$, $p\neq q$ and $pq\ge0$.
            \item [$\circ$] $g$ is a predicate over $V$
            \item [$\circ$] $\psi: V\to \E_V$ is a reassignment
          \end{itemize}
  \end{itemize}
  We can ignore the emitted action and write $s\xrightarrow{\beta_{j}^{j\in J}, g, \psi}s'$. A pair $(s, \phi)$, where $s\in S$ and $\phi:V\to\P$ is called a configuration of the automaton.
\end{definition}

\begin{definition}
  Consider automata
  $$A=\llangle S_A, s_{0A}, E_A, V_A, \psi_{0A}, T_A\rrangle \text{ and } B=\llangle S_B, s_{0B}, E_B, V_B, \psi_{0B}, T_B\rrangle.$$

  The composition of $B$ into the internal component indexed by $p<0$ of $A$ yields an open automaton $A[B/p]:=C=\llangle S_C, s_{0C}, E_C, V_C, \psi_{0C}\rrangle$, such that
  \begin{itemize}
    \item $S_C = S_A\times S_B$
    \item $s_{0C} = (s_{0A}, s_{0B})$
    \item $E_C = E_A\times E_B$
    \item $V_C = V_A\uplus V_B$
    \item $\psi_C = \psi_A\uplus \psi_B$
    \item $T_C = \left\{\Bigg|\dfrac{\beta, g, \psi}{s\xrightarrow{\alpha} t}\in T_A, \dfrac{\beta', g', \psi'}{s'\xrightarrow{\alpha'} t'}\in T_B\right\}$
  \end{itemize}
\end{definition}